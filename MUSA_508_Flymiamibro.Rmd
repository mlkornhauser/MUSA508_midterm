---
title: "MUSA 508 Midterm: Miami Home Sales Prediction"
author: "Flymiamibro:  Maddy Kornhauser & Adam Ghazzawi"
date: "10/13/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(sf)
library(spdep)
library(caret)
library(ckanr)
library(FNN)
library(grid)
library(gridExtra)
library(ggcorrplot)
library(osmdata)
library(Hmisc)
library(tidycensus)
library(kableExtra)
library(stargazer)

root.dir = "https://github.com/mlkornhauser/MUSA508_midterm.git"

mapTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle=element_text(face="italic"),
    plot.caption=element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),axis.title = element_blank(),
    axis.text = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2)
  )
}

plotTheme <- function(base_size = 12) {
  theme(
    text = element_text( color = "black"),
    plot.title = element_text(size = 14,colour = "black"),
    plot.subtitle = element_text(face="italic"),
    plot.caption = element_text(hjust=0),
    axis.ticks = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_line("grey80", size = 0.1),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=2),
    strip.background = element_rect(fill = "grey80", color = "white"),
    strip.text = element_text(size=12),
    axis.title = element_text(size=12),
    axis.text = element_text(size=10),
    plot.background = element_blank(),
    legend.background = element_blank(),
    legend.title = element_text(colour = "black", face = "italic"),
    legend.text = element_text(colour = "black", face = "italic"),
    strip.text.x = element_text(size = 14)
  )
}

palette5 <- c('#f07167','#fed9b7','#fdfcdc','#00afb9', '#0081a7')

qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]]), digits = 3),
                 c(.01,.2,.4,.6,.8), na.rm=T)
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}

nn_function <- function(measureFrom,measureTo,k) {
  measureFrom_Matrix <- as.matrix(measureFrom)
  measureTo_Matrix <- as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    dplyr::summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}

```

## 1. Introduction

Known for its beautiful beaches, vibrant culture, and lively nightlife, Miami and neighboring Miami Beach are a major hub for business and tourism. Located at the southeastern tip of Florida, the cities are a popular destination for domestic and international visitors and act as an economic powerhouse for the region. But how do these local amenities factor into home prices for residents? We developed a machine-learning model to predict sale prices to account for these local features that Miami residents value when buying a home. We strived to make the model both accurate and generalizable, so the model can predict on new data. [Explain this better] The model's ability to generalize in new contexts means it is useful for a variety of needs, from market studies in the development world to property tax assessment in the public realm.

Creating this model is a difficult task with unavoidable imperfections. Even within Miami and Miami Beach, the housing market is incredibly varied in terms of price, location and nearby amenities. While it is imposible to account for all features that factor into a home's sale price, this model looksc at three main and fairly comprehensive categories to predict home prices: the home's physical charateristics, nearby public services and amenities, and the prices of nearby homes. To test the model's generalizability, we split our data into two groups of test and train  data. We ran the model on the train dataset and then on the test dataset to assess how well the model can be used to predict new data.

On average, we predicted housing prices within [$xxxx] and [%%%] of the sales price. In particular, our model was successful in predicting high value properties located in Miami Beach and along the coast of Miami. In general, the model was less successful in predicting home prices in the western, majority-Hispanic neighborhoods of Miami.

***MAKE SURE THIS IS CORRECT!

## 2. Data

As noted in the introduction, we collected the following data types listed below.

1. *Physical Home Characteristics*: These features were engineered from the initial dataset listing out the individual home observations to account for structural features that impact a home's price. Examples of these characteristics include the number of bedrooms, the square footage, or additional features that accompany the home, like the presence of a pool.

2. *Public Services and Amenities*: These data were pulled from Miami's open data portal and Open street Map (OSM) to account for surrounding businesses and services that may affect a home's price. Examples of this second type of characteristics incude the distance to the nearest supermarket or the number of restaurants within a half mile radius of the home.

3. *Demographic & Census Data*: While not necessarily the same as specific amenities and services available, we incorporated census data that we thought was an acceptable proxy for missing amenity (or in some cases, disamenity) data. For example, while individual crime data was not available through open data portals, we used median household income data as a proxy for crime rate under the assumption that lower-income census tracts have higher crime rates. We also found that incorporating certain demographic variables from the census improved our model's predictive power. These variables included the share of the population identifying as hispanic and population over the age of 40. 

4. *Price Clustering*: We studied how prices clustered together at the neighborhood level and within a half-mile buffer of each home. Some of these variables were generated by imposing neighborhood boundaries on the individual home data and identifying which neighborhood each property belonged to. We also identified high and low value homes from the original dataset and generated variables to explain how close those were to each other.

### Data Setup

Based on available open data, the following lines of code pull the municipal boundaries for Miami-Dade County and filter to only return polygons for Miami and Miami Beach. We created a bounding box that we used specifically to pull OSM data, which pulls in data as unprojected coordinates. The base polygon was then projected and transformed into an sf object that was used as a base for all other data incorporated into the model.  

Finally, we imported the training dataset and projected it to match our base polygon. Figure XX below shows each of the properties by sales price quintile 

```{r, message=FALSE, warning=FALSE, include=FALSE, paged.print=TRUE}
miami.base <- 
  st_read("https://opendata.arcgis.com/datasets/5ece0745e24b4617a49f2e098df8117f_0.geojson") %>%
  filter(NAME == "MIAMI BEACH" | NAME == "MIAMI") %>%
  st_union() #Need to keep miami.base unprojected to pull and filter OSM data
``` 

```{r echo=FALSE, message=FALSE, warning=FALSE}
miami.base.sf <- miami.base %>%
  st_as_sf(coords = "geometry", crs = 4326, agr = "constant") %>%
  st_transform('ESRI:102658') 

#Setting the bounding box
xmin = st_bbox(miami.base)[[1]]
ymin = st_bbox(miami.base)[[2]]
xmax = st_bbox(miami.base)[[3]]  
ymax = st_bbox(miami.base)[[4]]

#Housing data
miami <- st_read('data/studentsData.geojson')
miami.sf  <- miami %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, agr = "constant") %>%
  st_transform(st_crs(miami.base.sf))
```

Next, we manipulated the housing data to engineer physical home characteristics that we were interested incorporating into our model. Certain variables, such as property Age and PriceperSQFT, required us to perform a mathematical function on numerical values already present in the data. Other variables that indicated if the home included a specific feature, such as a pool or a dock, required us to pull text strings out of the XF columns and create a separate binary dummy variable to indicate if the feature applied to a certain property.

```{r echo=FALSE}
miami.sf <- miami.sf %>% 
  mutate(Age = 2020 - YearBuilt,
         PriceperSQFT = SalePrice / ActualSqFt) 
miami.sf$Zip_short <- substr(miami.sf$Property.Zip, 1, 5)

#Pool
poollist <- list("Pool 6' res BETTER 3-8' dpth, tile 250-649 sf",
                 "Pool 6' res AVG 3-8' dpth, plain feat 250-649 sf",
                 "Pool 8' res BETTER 3-8' dpth, tile 650-1000 sf",
                 "Pool COMM AVG 3-6' dpth, plain feat 15x30 av size",
                 "Luxury Pool - Good.",
                 "Luxury Pool - Better",
                 "Luxury Pool - Better")
miami.sf <- 
  miami.sf %>%
  mutate(Pool_1 = XF1 %in% poollist, 
         Pool_2 = XF2 %in% poollist, 
         Pool_3 = XF3 %in% poollist)
miami.sf$Pool <- ifelse(miami.sf$Pool_1 == "TRUE" | 
                          miami.sf$Pool_2 == "TRUE" | 
                          miami.sf$Pool_3 == "TRUE", 1, 0)
drop <- c("Pool_1","Pool_2","Pool_3")
miami.sf <- miami.sf[,!(names(miami.sf) %in% drop)]

#Luxury Pool
luxpoollist <- list( "Luxury Pool - Good.",
                     "Luxury Pool - Better",
                     "Luxury Pool - Better")
miami.sf <- miami.sf %>%
  mutate(LuxPool_1 = XF1 %in% luxpoollist, LuxPool_2 = XF2 %in% luxpoollist, LuxPool_3 = XF3 %in% luxpoollist)
miami.sf$LuxPool <- ifelse(miami.sf$LuxPool_1 == "TRUE" | 
                          miami.sf$LuxPool_2 == "TRUE" | 
                          miami.sf$LuxPool_3 == "TRUE", 1, 0)
drop <- c("LuxPool_1","LuxPool_2","LuxPool_3")
miami.sf <- miami.sf[,!(names(miami.sf) %in% drop)]

#Dock
docklist <- list("Dock - Wood on Light Posts",      
                 "Dock - Wood Girders on Concrete Pilings",
                 "Dock - Concrete Griders on Concrete Pilings")
miami.sf <- miami.sf %>%
  mutate(
    Dock_1 = XF1 %in% docklist,
    Dock_2 = XF2 %in% docklist, 
    Dock_3 = XF3 %in% docklist)
miami.sf$Dock <- ifelse(miami.sf$Dock_1 == "TRUE" | 
                          miami.sf$Dock_2 == "TRUE" | 
                          miami.sf$Dock_3 == "TRUE", 1, 0)
drop <- c("Dock_1","Dock_2","Dock_3")
miami.sf <- miami.sf[,!(names(miami.sf) %in% drop)]

#Patio
patiolist <- list("Patio - Screened over Concrete Slab",
                  "Patio - Concrete Slab",
                  "Patio - Terrazzo, Pebble",
                  "Patio - Brick, Tile, Flagstone",
                  "Patio - Wood Deck",
                  "Patio - Concrete Slab w/Roof Aluminum or Fiber",
                  "Patio - Concrete stamped or stained",
                  "Patio - Marble")
miami.sf <- miami.sf %>%
  mutate(
    Patio_1 = XF1 %in% patiolist,
    Patio_2 = XF2 %in% patiolist, 
    Patio_3 = XF3 %in% patiolist)
miami.sf$Patio <- ifelse(miami.sf$Patio_1 == "TRUE" | 
                          miami.sf$Patio_2 == "TRUE" | 
                          miami.sf$Patio_3 == "TRUE", 1, 0)
drop <- c("Patio_1","Patio_2","Patio_3")
miami.sf <- miami.sf[,!(names(miami.sf) %in% drop)]

#Elevator
elevlist <- list("Elevator - Passenger")
miami.sf <- miami.sf %>%
  mutate(
    elev_1 = XF1 %in% elevlist,
    elev_2 = XF2 %in% elevlist, 
    elev_3 = XF3 %in% elevlist)
miami.sf$Elevator <- ifelse(miami.sf$elev_1 == "TRUE" | 
                             miami.sf$elev_2 == "TRUE" | 
                             miami.sf$elev_3 == "TRUE", 1, 0)
drop <- c("elev_1","elev_2","elev_3")
miami.sf <- miami.sf[,!(names(miami.sf) %in% drop)]

head(miami.sf) %>%
  dplyr::select(PriceperSQFT, AdjustedSqFt, Bed, Pool, 
                LuxPool, Dock, Patio, Elevator) %>%
  st_drop_geometry()
```

We then incorporated locational data about local Miami businesses and amenities that may impact a home's sale price. We pulled these data from open sources include the Miami-Dade data portal and OSM. We then calculated the average nearest neighbor distance to determine how close each home was to these amenities. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
st_c <- st_coordinates

#----Assisted Living (GEOJSON)
assisted_living <- st_read('https://opendata.arcgis.com/datasets/9bb1ec069f134635b6fcb0173408a23d_0.geojson')
assisted.sf <- assisted_living%>%
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf()
assisted.sf <- st_join(assisted.sf, miami.base.sf, join = st_intersects, left = FALSE)

miami.sf <-
  miami.sf %>%
  mutate(
    assisted_nn4 = nn_function(st_c(st_centroid(miami.sf)), st_c(st_centroid(assisted.sf)), 4))

#----Barber (GEOJSON)
commercial <- st_read('https://opendata.arcgis.com/datasets/fb8303c577c24ea386a91be7329842be_0.geojson')
commercial.sf <- 
  commercial %>%
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf() 
commercial.sf <- st_join(commercial.sf, miami.base.sf, join = st_intersects, left = FALSE)

Barber <- commercial.sf %>% subset(BUSDESC == "BARBER SHOPS\n")
miami.sf <- miami.sf %>%
  mutate(barber_nn4 = nn_function(st_c(st_centroid(miami.sf)), st_c(st_centroid(Barber)), 4))

#----Beaches (GEOJSON)
beaches <- st_read('https://opendata.arcgis.com/datasets/d0d6e6c9d47145a0b05d6621ef29d731_0.geojson') 
beaches.sf <- beaches %>% #project and convert to sf object
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf() %>%
  st_union()

BeachDistance <- st_distance(miami.sf, beaches.sf, by_element = TRUE)
BeachDistance <- as.vector(BeachDistance)
miami.sf$BeachDist <- BeachDistance

#----Convenience Store (OSM)
convenience <- opq(bbox = c(xmin, ymin, xmax, ymax)) %>% 
  add_osm_feature(key = 'shop', value = c("convenience")) %>%
  osmdata_sf()

convenience <- 
  convenience$osm_points %>%
  .[miami.base,]

convenience.sf <- convenience %>%
  dplyr::select(geometry) %>%
  na.omit() %>%
  st_transform(st_crs(miami.sf)) %>%
  distinct()

miami.sf <- miami.sf %>%
  mutate(convenience_nn4 = nn_function(st_c(st_centroid(miami.sf)), st_c(st_centroid(convenience.sf)), 4))

#----Hotel (GEOJSON)
hotel <- st_read('https://opendata.arcgis.com/datasets/d37bbc15e7304b4ca4607783283147b7_0.geojson') 
hotel.sf <- hotel %>%
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf() 
hotel.sf <- st_join(hotel.sf, miami.base.sf, join = st_intersects, left = FALSE)

hotel.sf <- 
  hotel %>%
  na.omit() %>%
  st_transform(st_crs(miami.sf)) %>%
  distinct()

miami.sf <- miami.sf %>%
  mutate(hotel_nn4 = nn_function(st_c(st_centroid(miami.sf)), st_c(st_centroid(hotel.sf)), 4))

#----Malls (GEOJSON)
malls <- st_read('https://opendata.arcgis.com/datasets/cb24d578246647a9a4c57bbd80c1caa8_0.geojson') 
malls.sf <- malls %>%
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf() 
malls.sf <- st_join(malls.sf, miami.base.sf, join = st_intersects, left = FALSE)

miami.sf <-
  miami.sf %>%
  mutate(malls_nn4 = nn_function(st_c(st_centroid(miami.sf)), st_c(st_centroid(malls.sf)), 4))

head(miami.sf) %>%
  dplyr::select(assisted_nn4, BeachDist, barber_nn4, convenience_nn4, hotel_nn4, malls_nn4) %>%
  st_drop_geometry()
```

We then pulled census data usng the tidycensus package. 

```{r}
#tidycensus pull
tracts18 <-
  get_acs(geography = "tract", variables = c("B01003_001E", "B02001_002E", "B01002_001E",
                                             "B19013_001E", "B17020_002E", "B03001_003E"),
          year=2018, state="Florida", county="Miami-Dade", geometry=T, output = "wide") %>%
  st_transform(st_crs(miami.sf)) %>%
  rename(TotalPop = B01003_001E,
         Whites = B02001_002E,
         MedAge = B01002_001E,
         MedHHInc = B19013_001E,
         Poverty = B17020_002E,
         Hisp = 	B03001_003E) %>%
  dplyr::select(-NAME, -starts_with("B")) %>%
  mutate(pctHisp = ifelse(TotalPop >0, Hisp / TotalPop,0),
         MedAge40up = ifelse(MedAge > 40,1,0),
         year = "2018") %>%
  dplyr::select(-Whites, -Poverty, -Hisp) 

#joining tract data to Miami housing data
miami.sf <- st_join(st_centroid(miami.sf), tracts18, join = st_intersects, left = TRUE, largest = TRUE)

#Converting NA values to 0
miami.sf$TotalPop[is.na(miami.sf$TotalPop)] <- 0
miami.sf$MedAge[is.na(miami.sf$MedAge)] <- 0
miami.sf$MedHHInc[is.na(miami.sf$MedHHInc)] <- 0
miami.sf$pctHisp[is.na(miami.sf$pctHisp)] <- 0
```
```{r}
head(miami.sf) %>%
  dplyr::select(MedAge40up, MedHHInc, pctHisp) %>%
  st_drop_geometry()
```

Finally, to account for the spatial process of home prices, we engineered variables to account for properties in the most expensive neighborhoods. To achieve this, we loaded in a shapefile with Miami neighborhoods. However, since Miami Beach is technically a separate municipality, this was not included. Therefore, we isolated the Miami Beach polygon and combined it with the neighborhoods shapefile using the st_union() function as shown in the below Figure X.X. We then spatially joined the neighborhood data to the Miami housing data so each property was assigned a neighborhood.

```{r}
#read in data
nhoods <- st_read('https://opendata.arcgis.com/datasets/2f54a0cbd67046f2bd100fb735176e6c_0.geojson')
miamibeach  <-
  st_read("https://opendata.arcgis.com/datasets/5ece0745e24b4617a49f2e098df8117f_0.geojson") %>%
  filter(NAME == "MIAMI BEACH")

#add Miami Beach to Miami neighborhood shapefile
nhoods <- st_union(nhoods, miamibeach) %>% ungroup() 
nhoods$LABEL[nhoods$FID==107] <- "Miami Beach"

#Convert new neighborhoods shapefile into sf object and project
nhoods.sf <-
  nhoods %>%
  dplyr::select(LABEL, geometry) %>%
  st_transform(st_crs(miami.base.sf)) %>%
  st_as_sf() 
nhoods.sf <- st_cast(nhoods.sf, "POLYGON")

#Spatially join neigborhoods shapefile to miami housing data
miami.sf <- st_join(st_centroid(miami.sf), nhoods.sf, join = st_intersects, left = TRUE, largest = TRUE)

#Plotting neighborhood boundaries
ggplot() +
  geom_sf(data = nhoods.sf, fill = "grey60") +
  labs(title="Miami Neighborhood Boundaries",
       subtitle = "Figure X.X") +
  mapTheme()
```

We then calculated a binary dummy variable to indicate if a property was located in one of the top 5 most expensive neighborhoods. We engineered addiitonal variables to count the number homes sold for over $10 million and the number of homes below the median sale price within a half-mile buffer of each property.

```{r}
#Property in engibhorhood with top average sales price
topavgnhoodlist <- list("San Marco Island",
                        "Biscayne Island",
                        "South Grove Bayside",
                        "Baypoint",
                        "Belle Island")
miami.sf <- miami.sf %>%
  mutate(TopAvgNhood = LABEL %in% topavgnhoodlist)
miami.sf$TopAvgNhood <- ifelse(miami.sf$TopAvgNhood == "TRUE", 1, 0)

#Number of sale prices over $10m within half-mile buffer
neighbor.10M <- miami.sf %>% subset(SalePrice > 10000000)
neighbor.10M.sf <-neighbor.10M %>%
  dplyr::select(geometry) %>%
  na.omit() %>%
  st_transform(st_crs(miami.base.sf))%>%
  distinct()
miami.sf$neighbor.10M_1320 =
  st_buffer(miami.sf, 1320) %>%
  aggregate(mutate(neighbor.10M.sf, counter = 1),., sum) %>%
  pull(counter)
miami.sf$neighbor.10M_1320[is.na(miami.sf$neighbor.10M_1320)] <- 0

#Number of sale prices below median sales prices within half-mile buffer
BelowMedPrice <- miami.sf %>% subset(SalePrice < median(miami.sf$SalePrice))
BelowMedPrice.sf <-
  BelowMedPrice %>%
  dplyr::select(geometry) %>%
  na.omit() %>%
  st_transform(st_crs(miami.base.sf))%>%
  distinct()
miami.sf$BelowMedPrice_1320 =
  st_buffer(miami.sf, 1320) %>%
  aggregate(mutate(BelowMedPrice.sf, counter = 1),., sum) %>%
  pull(counter)
miami.sf$BelowMedPrice_1320[is.na(miami.sf$BelowMedPrice_1320)] <- 0

head(miami.sf) %>%
  dplyr::select(TopAvgNhood, neighbor.10M_1320, BelowMedPrice_1320) %>%
  st_drop_geometry()
```
```{r}
VarSummary <- miami.sf %>%
  dplyr::select(SalePrice,
                PriceperSQFT, AdjustedSqFt, Bed, Pool, LuxPool, Dock, Patio, Elevator,
                assisted_nn4, BeachDist, barber_nn4, convenience_nn4, hotel_nn4, malls_nn4,
                MedAge40up, MedHHInc, pctHisp,
                TopAvgNhood, neighbor.10M_1320, BelowMedPrice_1320) %>%
  st_drop_geometry()

VarSummary %>% 
stargazer(type = "html", 
title = "Model Variable Study", 
summary = TRUE)
# Need to figure out how to add variable category to this table.  
# 
# add.lines = c("Dependent", "Internal", "Internal", "Internal", "Internal", "Internal", "Internal",
#                  "Internal", "Internal", "Amenity/Service", "Amenity/Service", "Amenity/Service", 
#                  "Amenity/Service","Amenity/Service", "Amenity/Service", "Census/Demographic", 
#                  "Census/Demographic", "Census/Demographic", "Spatial Structure", "Spatial Structure", "Spatial Structure"))
          
```

###Exploratory Analysis

After loading and wrangling the variables, we wanted to understand their individual relationships to the dependent variable SalePrice. The blue squares indicate that there is a strong positive correlation and the dark pink indicates a strong negative correlation. The less saturated, the weaker the relationship between the variables.

```{r}
numericVars <- 
  select_if(st_drop_geometry(miami.sf), is.numeric) %>%
  dplyr::select(SalePrice,
                PriceperSQFT, AdjustedSqFt, Bed, Pool, LuxPool, Dock, Patio, Elevator,
                assisted_nn4, BeachDist, barber_nn4, convenience_nn4, hotel_nn4, malls_nn4,
                MedAge40up, MedHHInc, pctHisp, TopAvgNhood, neighbor.10M_1320, BelowMedPrice_1320) %>%
  na.omit()

ggcorrplot(
  round(cor(numericVars), 1), 
  p.mat = cor_pmat(numericVars),
  colors = c("#f765b8", "white", "#27fdf5"),
  type="lower",
  insig = "blank") +  
  labs(title = "Correlation across numeric variables") 
```

We also looked at correlation through a series of scatter plots comparing the indepedent variables to the individual variables. A selection of these plots are shown below.

[INCLUDE ANALYSIS OF INDIVIDUAL VARIABLES]

```{r}
st_drop_geometry(miami.sf) %>% 
  dplyr::select(SalePrice, 
                assisted_nn4, 
                barber_nn4, 
                malls_nn4, 
                neighbor.10M_1320) %>% 
  gather(Variable, Value, -SalePrice) %>% #convert to long format
  ggplot(aes(Value, SalePrice)) + #plot
  geom_point(size = .5) + geom_smooth(method = "lm", se=F, colour = "#FA7800") +
  facet_wrap(~Variable, ncol = 4, scales = "free") +
  labs(title = "Price as a function of continuous variables") +
  plotTheme()
```

We also created a map of sales price throughout Miami showing the variation in price as well as demonstrating the non-random clustering of home prices in Miami.

```{r}
ggplot() +
  geom_sf(data = miami.base.sf, fill = "grey60") +
  geom_sf(data = miami.sf, aes(colour = q5(SalePrice)), 
          show.legend = "point", size = .75) +
  scale_colour_manual(values = palette5) +
  labs(title="Sales Price, Miami",
       subtitle = "Figure X.X") +
  mapTheme()
```

[INCLUDE 3 Maps of INDEPENDENT VARIABLES]